import datetime
import httplib
import main
import threading

from clock import FakeClock
from code_constants import (PPI_SYSTEM, RACE_WHITE_CODE, CONSENT_PERMISSION_YES_CODE,
                            RACE_NONE_OF_THESE_CODE, PMI_SKIP_CODE)
from concepts import Concept
from dao.biobank_stored_sample_dao import BiobankStoredSampleDao
from dao.participant_summary_dao import ParticipantSummaryDao
from model.code import CodeType
from model.biobank_stored_sample import BiobankStoredSample
from participant_enums import ANSWER_CODE_TO_RACE
from test_data import load_measurement_json, load_biobank_order_json
from unit_test_util import FlaskTestBase, make_questionnaire_response_json, SqlTestBase


TIME_1 = datetime.datetime(2016, 1, 1)
TIME_2 = datetime.datetime(2016, 1, 2)
TIME_3 = datetime.datetime(2016, 1, 3)
TIME_4 = datetime.datetime(2016, 1, 4)
TIME_5 = datetime.datetime(2016, 1, 5, 0, 1)
TIME_6 = datetime.datetime(2015, 1, 1)

class ParticipantSummaryMySqlApiTest(FlaskTestBase):

  def setUp(self):
    super(ParticipantSummaryMySqlApiTest, self).setUp(use_mysql=True)
    self.provider_link = {
      "primary": True,
      "organization": {
        "display": None,
        "reference": "Organization/PITT",
      },
      "site": [{
        "display": None,
        "reference": "mayo-clinic",
      }],
      "identifier": [{
        "system": "http://any-columbia-mrn-system",
        "value": "MRN456"
      }]
    }

  def testUpdate_raceCondition(self):
    self.create_questionnaire('questionnaire3.json')
    participant = self.send_post('Participant', {})
    participant_id = participant['participantId']
    participant['providerLink'] = [self.provider_link]

    t1 = threading.Thread(target=lambda:
                          self.send_put('Participant/%s' % participant_id, participant,
                                        headers={'If-Match': participant['meta']['versionId']}))

    t2 = threading.Thread(target=lambda:
                          self.send_consent(participant_id))
    t1.start()
    t2.start()
    t1.join()
    t2.join()

    # The participant summary should exist (consent has been received), and it should have PITT
    # for its HPO ID (the participant update occurred.)
    # This used to fail a decent percentage of the time, before we started using FOR UPDATE in
    # our update statements; see DA-256.
    ps = self.send_get('Participant/%s/Summary' % participant_id)
    self.assertEquals('PITT', ps.get('hpoId'))


class ParticipantSummaryApiTest(FlaskTestBase):
  provider_link = {
    "primary": True,
    "organization": {
      "display": None,
      "reference": "Organization/PITT",
    }
  }
  az_provider_link = {
    "primary": True,
    "organization": {
      "display": None,
      "reference": "Organization/AZ_TUCSON",
    }
  }
  # Some link ids relevant to the demographics questionnaire
  code_link_ids = (
      'race', 'genderIdentity', 'state', 'sex', 'sexualOrientation', 'recontactMethod', 'language',
      'education', 'income'
  )
  string_link_ids = (
      'firstName', 'middleName', 'lastName', 'streetAddress', 'city', 'phoneNumber', 'zipCode'
  )

  def create_demographics_questionnaire(self):
    """Uses the demographics test data questionnaire.  Returns the questionnaire id"""
    return self.create_questionnaire('questionnaire3.json')

  def create_expected_response(self, participant, answers):
    """Generates what we should expect as the return value of the participant summary API after the
    given participant has submitted the given answers to the questionnaire generated by
    `create_demographics_questionnaire`.
    """
    # Remove the signature field if it exists
    answers.pop('CABoRSignature', None)
    # Copy and mutate the copy, not the original answer dict
    expected = dict(answers)
    # These properties are mutated in between sending and retrieving, they require special handling
    if 'dateOfBirth' in answers:
      dob = answers['dateOfBirth']
      expected['dateOfBirth'] = '{}-{:02d}-{:02d}'.format(dob.year, dob.month, dob.day)
    if 'race' in answers:
      expected['race'] = str(ANSWER_CODE_TO_RACE.get(answers['race']))

    expected.update({
      'questionnaireOnHealthcareAccess': 'UNSET',
      'enrollmentStatus': 'INTERESTED',
      'samplesToIsolateDNA': 'UNSET',
      'questionnaireOnOverallHealth': 'UNSET',
      'signUpTime': participant['signUpTime'],
      'biobankId': participant['biobankId'],
      'numBaselineSamplesArrived': 0,
      'questionnaireOnTheBasics': 'SUBMITTED',
      'questionnaireOnTheBasicsTime': TIME_1.isoformat(),
      'questionnaireOnLifestyle': 'UNSET',
      'questionnaireOnFamilyHealth': 'UNSET',
      'questionnaireOnMedications': 'UNSET',
      'physicalMeasurementsStatus': 'UNSET',
      'biospecimenStatus': 'UNSET',
      'biospecimenSourceSite': 'UNSET',
      'biospecimenCollectedSite': 'UNSET',
      'biospecimenProcessedSite': 'UNSET',
      'biospecimenFinalizedSite': 'UNSET',
      'physicalMeasurementsCreatedSite': 'UNSET',
      'physicalMeasurementsFinalizedSite': 'UNSET',
      'sampleOrderStatus1ED04': 'UNSET',
      'sampleOrderStatus1ED10': 'UNSET',
      'sampleOrderStatus1HEP4': 'UNSET',
      'sampleOrderStatus1PST8': 'UNSET',
      'sampleOrderStatus1PS08': 'UNSET',
      'sampleOrderStatus1SAL': 'UNSET',
      'sampleOrderStatus1SST8': 'UNSET',
      'sampleOrderStatus1SS08': 'UNSET',
      'sampleOrderStatus1UR10': 'UNSET',
      'sampleOrderStatus2ED10': 'UNSET',
      'sampleOrderStatus2PST8': 'UNSET',
      'sampleOrderStatus2SST8': 'UNSET',
      'sampleStatus1ED04': 'UNSET',
      'sampleStatus1ED10': 'UNSET',
      'sampleStatus1HEP4': 'UNSET',
      'sampleStatus1PST8': 'UNSET',
      'sampleStatus1PS08': 'UNSET',
      'sampleStatus1SAL': 'UNSET',
      'sampleStatus1SST8': 'UNSET',
      'sampleStatus1SS08': 'UNSET',
      'sampleStatus1UR10': 'UNSET',
      'sampleStatus2ED10': 'UNSET',
      'sampleStatus2PST8': 'UNSET',
      'sampleStatus2SST8': 'UNSET',
      'consentForElectronicHealthRecords': 'UNSET',
      'consentForCABoR': 'SUBMITTED',
      'consentForCABoRTime': TIME_1.isoformat(),
      'questionnaireOnMedicalHistory': u'UNSET',
      'participantId': participant['participantId'],
      'hpoId': 'PITT',
      'awardee': 'PITT',
      'site': 'UNSET',
      'organization': 'UNSET',
      'numCompletedPPIModules': 1,
      'numCompletedBaselinePPIModules': 1,
      'consentForStudyEnrollment': 'SUBMITTED',
      'consentForStudyEnrollmentTime': TIME_1.isoformat(),
      'ageRange': '36-45',
      'email': self.email,
      'withdrawalStatus': 'NOT_WITHDRAWN',
      'suspensionStatus': 'NOT_SUSPENDED',
    })

    return expected

  def post_demographics_questionnaire(self,
                                      participant_id,
                                      questionnaire_id,
                                      cabor_signature_string=False,
                                      time=TIME_1, **kwargs):
    """POSTs answers to the demographics questionnaire for the participant"""
    answers = {'code_answers': [],
               'string_answers': [],
               'date_answers': [('dateOfBirth', kwargs.get('dateOfBirth'))]}
    if cabor_signature_string:
      answers['string_answers'].append(('CABoRSignature', kwargs.get('CABoRSignature')))
    else:
      answers['uri_answers'] = [('CABoRSignature', kwargs.get('CABoRSignature'))]

    for link_id in self.code_link_ids:
      if link_id in kwargs:
        concept = Concept(PPI_SYSTEM, kwargs[link_id])
        answers['code_answers'].append((link_id, concept))

    for link_id in self.string_link_ids:
      code = kwargs.get(link_id)
      answers['string_answers'].append((link_id, code))

    response_data = make_questionnaire_response_json(participant_id, questionnaire_id, **answers)

    with FakeClock(time):
      url = 'Participant/%s/QuestionnaireResponse' % participant_id
      return self.send_post(url, request_data=response_data)

  def test_pairing_summary(self):
    participant = self.send_post('Participant', {"providerLink": [self.provider_link]})
    participant_id = participant['participantId']
    path = 'Participant/%s' % participant_id
    participant['awardee'] = 'PITT'
    particpant_update = self.send_put(path, participant, headers={'If-Match': 'W/"1"'})
    self.assertEquals(particpant_update['awardee'], participant['awardee'])
    participant['organization'] = 'AZ_TUCSON_BANNER_HEALTH'
    participant_update_2 = self.send_put(path, participant, headers={'If-Match': 'W/"2"'})
    self.assertEquals(participant_update_2['organization'], participant['organization'])
    self.assertEquals(participant_update_2['awardee'], 'AZ_TUCSON')

  def testQuery_noParticipants(self):
    self.send_get('Participant/P1/Summary', expected_status=httplib.NOT_FOUND)
    response = self.send_get('ParticipantSummary')
    self.assertBundle([], response)

  def submit_questionnaire_response(self, participant_id, questionnaire_id, race_code, gender_code,
                                    first_name, middle_name, last_name, zip_code,
                                    state_code, street_address, city, sex_code,
                                    sexual_orientation_code, phone_number, recontact_method_code,
                                    language_code, education_code, income_code, date_of_birth,
                                    cabor_signature_uri):
    code_answers = []
    _add_code_answer(code_answers, "race", race_code)
    _add_code_answer(code_answers, "genderIdentity", gender_code)
    _add_code_answer(code_answers, "state", state_code)
    _add_code_answer(code_answers, "sex", sex_code)
    _add_code_answer(code_answers, "sexualOrientation", sexual_orientation_code)
    _add_code_answer(code_answers, "recontactMethod", recontact_method_code)
    _add_code_answer(code_answers, "language", language_code)
    _add_code_answer(code_answers, "education", education_code)
    _add_code_answer(code_answers, "income", income_code)

    qr = make_questionnaire_response_json(participant_id,
                                          questionnaire_id,
                                          code_answers = code_answers,
                                          string_answers = [("firstName", first_name),
                                                            ("middleName", middle_name),
                                                            ("lastName", last_name),
                                                            ("streetAddress", street_address),
                                                            ("city", city),
                                                            ("phoneNumber", phone_number),
                                                            ("zipCode", zip_code)],
                                          date_answers = [("dateOfBirth", date_of_birth)],
                                          uri_answers = [("CABoRSignature", cabor_signature_uri)])
    with FakeClock(TIME_1):
      self.send_post('Participant/%s/QuestionnaireResponse' % participant_id, qr)

  def testQuery_noSummaries(self):
    participant = self.send_post('Participant', {"providerLink": [self.provider_link]})
    participant_id = participant['participantId']
    self.send_get('Participant/%s/Summary' % participant_id, expected_status=httplib.NOT_FOUND)
    response = self.send_get('ParticipantSummary')
    self.assertBundle([], response)

  def test_last_modified_sync(self):
    SqlTestBase.setup_codes([PMI_SKIP_CODE], code_type=CodeType.ANSWER)
    questionnaire_id = self.create_demographics_questionnaire()
    t1 = TIME_1
    t2 = TIME_1 + datetime.timedelta(seconds=200)
    t3 = t2 + datetime.timedelta(seconds=30)
    t4 = t3 + datetime.timedelta(seconds=30)
    # 1 minute buffer
    t5 = t4 + datetime.timedelta(seconds=30)

    def setup_participant(when, providerLink=self.provider_link):
      # Set up participant, questionnaire, and consent
      with FakeClock(when):
        participant = self.send_post('Participant', {"providerLink": [providerLink]})
        participant_id = participant['participantId']
        self.send_consent(participant_id)
        # Populate some answers to the questionnaire
        answers = {
          'race': RACE_WHITE_CODE,
          'genderIdentity': PMI_SKIP_CODE,
          'firstName': self.fake.first_name(),
          'middleName': self.fake.first_name(),
          'lastName': self.fake.last_name(),
          'zipCode': '78751',
          'state': PMI_SKIP_CODE,
          'streetAddress': '1234 Main Street',
          'city': 'Austin',
          'sex': PMI_SKIP_CODE,
          'sexualOrientation': PMI_SKIP_CODE,
          'phoneNumber': '512-555-5555',
          'recontactMethod': PMI_SKIP_CODE,
          'language': PMI_SKIP_CODE,
          'education': PMI_SKIP_CODE,
          'income': PMI_SKIP_CODE,
          'dateOfBirth': datetime.date(1978, 10, 9),
          'CABoRSignature': 'signature.pdf',
        }
      self.post_demographics_questionnaire(participant_id, questionnaire_id, time=when, **answers)
      return participant

    # Create the first batch and fetch their summaries
    first_batch = [setup_participant(t1) for _ in range(5)]
    first_batch.extend([setup_participant(t2) for _ in range(2)])
    first_batch.extend([setup_participant(t3) for _ in range(3)])
    url = 'ParticipantSummary?_sort=lastModified&_sync=true&awardee=PITT'
    response = self.send_get(url)
    # We have the same number of participants as summaries
    self.assertEqual(len(response['entry']), len(first_batch))
    last_modified_list = list()
    first_batch_list = list()
    for i in response['entry']:
      last_modified_list.append(i['resource']['lastModified'])
    for i in first_batch:
      first_batch_list.append(i['lastModified'])

    self.assertListEqual(last_modified_list, sorted(first_batch_list))
    # With the same ID's (they're the same participants)
    self.assertEqual(
      sorted([p['participantId'] for p in first_batch]),
      sorted([p['resource']['participantId'] for p in response['entry']]),
    )
    self.assertEqual(sorted([p['resource']['lastModified'] for p in response['entry']]),
                      [p['resource']['lastModified'] for p in response['entry']])

    t1_list_ids = list()
    t2_list_ids = list()
    t3_list_ids = list()
    response_list_1 = list()
    response_list_2 = list()
    response_list_3 = list()

    for participant in first_batch:
      if participant['lastModified'] == t1.strftime('%Y''-''%m''-''%d''T''%X'):
        t1_list_ids.append(participant['participantId'])
      elif participant['lastModified'] == t2.strftime('%Y''-''%m''-''%d''T''%X'):
        t2_list_ids.append(participant['participantId'])
      else:
        t3_list_ids.append(participant['participantId'])

    for i in response['entry'][:5]:
      response_list_1.append(i['resource']['participantId'])

    for i in response['entry'][5:7]:
      response_list_2.append(i['resource']['participantId'])

    for i in response['entry'][7:]:
      response_list_3.append(i['resource']['participantId'])

    self.assertEqual(sorted(response_list_1), sorted(t1_list_ids))
    self.assertEqual(sorted(response_list_2), sorted(t2_list_ids))
    self.assertEqual(sorted(response_list_3), sorted(t3_list_ids))

    self.assertEqual(response['entry'][0]['resource']['lastModified'], t1.strftime(
      '%Y''-''%m''-''%d''T''%X'))
    self.assertEqual(response['entry'][1]['resource']['lastModified'], t1.strftime(
      '%Y''-''%m''-''%d''T''%X'))
    self.assertEqual(response['entry'][5]['resource']['lastModified'], t2.strftime(
      '%Y''-''%m''-''%d''T''%X'))
    self.assertEqual(response['entry'][7]['resource']['lastModified'], t3.strftime(
      '%Y''-''%m''-''%d''T''%X'))

    # Get the next chunk with the sync url
    # Verify that this is, in fact, a sync URL - not a next
    sync_url = response['link'][0]['url']
    index = sync_url.find('ParticipantSummary')
    self.assertEqual(response['link'][0]['relation'], 'sync')

    # Verify that the next sync has results from t2 and t3 (within BUFFER).
    response2 = self.send_get(sync_url[index:])
    self.assertEqual(len(response2['entry']), 5)
    self.assertEqual(response2['entry'][0]['resource']['lastModified'], t2.strftime(
      '%Y''-''%m''-''%d''T''%X'))
    self.assertEqual(response2['entry'][1]['resource']['lastModified'], t2.strftime(
      '%Y''-''%m''-''%d''T''%X'))
    self.assertEqual(response2['entry'][2]['resource']['lastModified'], t3.strftime(
      '%Y''-''%m''-''%d''T''%X'))
    self.assertEqual(response2['entry'][3]['resource']['lastModified'], t3.strftime(
      '%Y''-''%m''-''%d''T''%X'))
    self.assertEqual(response2['entry'][4]['resource']['lastModified'], t3.strftime(
      '%Y''-''%m''-''%d''T''%X'))
    # Create a second batch
    second_batch = [setup_participant(t4) for _ in range(10)]
    response3 = self.send_get(sync_url[index:])
    # We have the same number of participants as summaries
    self.assertEqual(len(response3['entry']), len(second_batch) + len(response2['entry']))

    no_count_url = 'ParticipantSummary?lastModified=lt%s&_sync=true&awardee=PITT' % TIME_4
    no_count_response = self.send_get(no_count_url)
    total_count = len(no_count_response['entry'])
    self.assertEquals(total_count, 20)
    url = 'ParticipantSummary?lastModified=lt%s&_count=10&_sync=true&awardee=PITT' % TIME_4
    response = self.send_get(url)
    self.assertEqual(len(response['entry']), 10)
    next_url = response['link'][0]['url']
    next_10 = self.send_get(next_url[index:])
    self.assertEqual(len(next_10['entry']), 10)

    sort_by_lastmodified = 'ParticipantSummary?_sync=true&awardee=PITT&_sort=lastModified'
    sort_lm_response = self.send_get(sort_by_lastmodified)
    self.assertEquals(len(sort_lm_response['entry']), 20)
    self.assertEquals(sort_lm_response['link'][0]['relation'], 'sync')
    # ensure same participants are returned before 5 min. buffer
    sync_url = sort_lm_response['link'][0]['url']
    setup_participant(t5)

    # az_provider_link should not be returned.
    setup_participant(t5, self.az_provider_link)
    sync_again = self.send_get(sync_url[index:])
    self.send_get(sort_by_lastmodified)
    self.assertEquals(len(sync_again['entry']), 14)
    # The last 14 participants from sort_lm_response should be equal to the sync_again response.
    self.assertEquals(sort_lm_response['entry'][7:], sync_again['entry'][:13])

    one_min_modified = list()
    for i in sync_again['entry']:
      one_min_modified.append(datetime.datetime.strptime(i['resource']['lastModified'],
                                                            '%Y''-''%m''-''%d''T''%X'))

    # Everything should be within 60 seconds.
    margin = datetime.timedelta(seconds=60)
    out_of_range_margin = datetime.timedelta(seconds=61)
    self.assertTrue(one_min_modified[0] + margin <= t5)
    self.assertTrue(t5 - margin >= one_min_modified[0])
    self.assertTrue(one_min_modified[-1] <= t5)
    self.assertFalse(one_min_modified[0] + out_of_range_margin <= t5)

    # participants with az_tucson still dont show up in sync.
    setup_participant(t5, self.az_provider_link)
    sync_again = self.send_get(sync_url[index:])
    self.send_get(sort_by_lastmodified)
    self.assertEquals(len(sync_again['entry']), 14)

  def test_get_summary_list_returns_total(self):
    page_size = 10
    num_participants = 20
    SqlTestBase.setup_codes([PMI_SKIP_CODE], code_type=CodeType.ANSWER)
    questionnaire_id = self.create_demographics_questionnaire()

    # Prove that no results means a total of zero (if requested)
    response = self.send_get('ParticipantSummary?_count=%d&_includeTotal=true' % page_size)
    self.assertEqual(0, response['total'])
    # ... but ONLY if requested
    response = self.send_get('ParticipantSummary?_count=%d' % page_size)
    self.assertIsNone(response.get('total'))

    # generate participants to count
    for _ in range(num_participants):
      # Set up participant, questionnaire, and consent
      participant = self.send_post('Participant', {"providerLink": [self.provider_link]})
      participant_id = participant['participantId']
      with FakeClock(TIME_1):
        self.send_consent(participant_id)
      # Populate some answers to the questionnaire
      answers = {
        'race': RACE_WHITE_CODE,
        'genderIdentity': PMI_SKIP_CODE,
        'firstName': self.fake.first_name(),
        'middleName': self.fake.first_name(),
        'lastName': self.fake.last_name(),
        'zipCode': '78751',
        'state': PMI_SKIP_CODE,
        'streetAddress': '1234 Main Street',
        'city': 'Austin',
        'sex': PMI_SKIP_CODE,
        'sexualOrientation': PMI_SKIP_CODE,
        'phoneNumber': '512-555-5555',
        'recontactMethod': PMI_SKIP_CODE,
        'language': PMI_SKIP_CODE,
        'education': PMI_SKIP_CODE,
        'income': PMI_SKIP_CODE,
        'dateOfBirth': datetime.date(1978, 10, 9),
        'CABoRSignature': 'signature.pdf',
      }
      self.post_demographics_questionnaire(participant_id, questionnaire_id, **answers)

    # Prove that without the query param, no total is returned
    response = self.send_get('ParticipantSummary?_count=%d' % page_size)
    self.assertIsNone(response.get('total'))
    # Prove that the count and page are accurate even when the page size is larger than the total
    url = 'ParticipantSummary?_count=%d&_includeTotal=true' % (num_participants * 2)
    response = self.send_get(url)
    self.assertEqual(response['total'], len(response['entry']))
    self.assertEqual(response['total'], num_participants)

    # Prove that the 'total' key is correct
    response = self.send_get('ParticipantSummary?_count=%d&_includeTotal=true' % page_size)
    self.assertEqual(num_participants, response['total'])
    # Prove that we're still only returning what's on a single page
    self.assertEqual(page_size, len(response['entry']))

    # Prove that the total remains consistent across pages
    next_url = response['link'][0]['url']
    # Shave off the front so send_get actually sends the right thing
    index = next_url.find('ParticipantSummary')
    response2 = self.send_get(next_url[index:])
    # Check that the total has remained the same and that it is still the total # participants
    self.assertEqual(response2['total'], response['total'])
    self.assertEqual(response2['total'], num_participants)

  def test_get_summary_with_skip_codes(self):
    # Set up the codes so they are mapped later.
    SqlTestBase.setup_codes([PMI_SKIP_CODE], code_type=CodeType.ANSWER)

    # Set up participant, questionnaire, and consent
    participant = self.send_post('Participant', {"providerLink": [self.provider_link]})
    participant_id = participant['participantId']
    questionnaire_id = self.create_demographics_questionnaire()

    with FakeClock(TIME_1):
      self.send_consent(participant_id)

    # Populate some answers to the questionnaire
    answers = {
      'race': RACE_WHITE_CODE,
      'genderIdentity': PMI_SKIP_CODE,
      'firstName': self.fake.first_name(),
      'middleName': self.fake.first_name(),
      'lastName': self.fake.last_name(),
      'zipCode': '78751',
      'state': PMI_SKIP_CODE,
      'streetAddress': '1234 Main Street',
      'city': 'Austin',
      'sex': PMI_SKIP_CODE,
      'sexualOrientation': PMI_SKIP_CODE,
      'phoneNumber': '512-555-5555',
      'recontactMethod': PMI_SKIP_CODE,
      'language': PMI_SKIP_CODE,
      'education': PMI_SKIP_CODE,
      'income': PMI_SKIP_CODE,
      'dateOfBirth': datetime.date(1978, 10, 9),
      'CABoRSignature': 'signature.pdf',
    }

    self.post_demographics_questionnaire(participant_id, questionnaire_id, **answers)

    # Read the answers back via ParticipantSummary
    with FakeClock(TIME_2):
      actual = self.send_get('Participant/%s/Summary' % participant_id)

    # copies the dictionary - some of these are altered slightly in transmission but most should be
    # the same
    expected = self.create_expected_response(participant, answers)

    self.assertJsonResponseMatches(expected, actual)
    response = self.send_get('ParticipantSummary')
    self.assertBundle([_make_entry(actual)], response)

  def test_get_summary_with_skip_code_for_race(self):
    # Set up the codes so they are mapped later.
    SqlTestBase.setup_codes([PMI_SKIP_CODE], code_type=CodeType.ANSWER)

    # Set up participant, questionnaire, and consent
    participant = self.send_post('Participant', {"providerLink": [self.provider_link]})
    participant_id = participant['participantId']
    questionnaire_id = self.create_demographics_questionnaire()

    with FakeClock(TIME_1):
      self.send_consent(participant_id)

    # Populate some answers to the questionnaire
    answers = {
      'race': PMI_SKIP_CODE,
      'genderIdentity': PMI_SKIP_CODE,
      'firstName': self.fake.first_name(),
      'middleName': self.fake.first_name(),
      'lastName': self.fake.last_name(),
      'zipCode': '78751',
      'state': PMI_SKIP_CODE,
      'streetAddress': '1234 Main Street',
      'city': 'Austin',
      'sex': PMI_SKIP_CODE,
      'sexualOrientation': PMI_SKIP_CODE,
      'phoneNumber': '512-555-5555',
      'recontactMethod': PMI_SKIP_CODE,
      'language': PMI_SKIP_CODE,
      'education': PMI_SKIP_CODE,
      'income': PMI_SKIP_CODE,
      'dateOfBirth': datetime.date(1978, 10, 9),
      'CABoRSignature': 'signature.pdf',
    }

    self.post_demographics_questionnaire(participant_id, questionnaire_id, **answers)

    # Read the answers back via ParticipantSummary
    with FakeClock(TIME_2):
      actual = self.send_get('Participant/%s/Summary' % participant_id)

    # copies the dictionary - some of these are altered slightly in transmission but most should be
    # the same
    expected = self.create_expected_response(participant, answers)

    self.assertJsonResponseMatches(expected, actual)
    response = self.send_get('ParticipantSummary')
    self.assertBundle([_make_entry(actual)], response)

  def testQuery_oneParticipant(self):
    # Set up the codes so they are mapped later.
    SqlTestBase.setup_codes(["PIIState_VA", "male_sex", "male", "straight", "email_code", "en",
                             "highschool", "lotsofmoney"], code_type=CodeType.ANSWER)
    participant = self.send_post('Participant', {"providerLink": [self.provider_link]})
    participant_id = participant['participantId']
    with FakeClock(TIME_1):
      self.send_consent(participant_id)
    questionnaire_id = self.create_questionnaire('questionnaire3.json')

    # Populate some answers to the questionnaire
    answers = {
      'race': RACE_WHITE_CODE,
      'genderIdentity': 'male',
      'firstName': self.fake.first_name(),
      'middleName': self.fake.first_name(),
      'lastName': self.fake.last_name(),
      'zipCode': '78751',
      'state': 'PIIState_VA',
      'streetAddress': '1234 Main Street',
      'city': 'Austin',
      'sex': 'male_sex',
      'sexualOrientation': 'straight',
      'phoneNumber': '512-555-5555',
      'recontactMethod': 'email_code',
      'language': 'en',
      'education': 'highschool',
      'income': 'lotsofmoney',
      'dateOfBirth': datetime.date(1978, 10, 9),
      'CABoRSignature': 'signature.pdf',
    }

    self.post_demographics_questionnaire(participant_id, questionnaire_id, **answers)

    with FakeClock(TIME_2):
      actual = self.send_get('Participant/%s/Summary' % participant_id)

    expected = self.create_expected_response(participant, answers)

    self.assertJsonResponseMatches(expected, actual)
    response = self.send_get('ParticipantSummary')
    self.assertBundle([_make_entry(actual)], response)

  def testQuery_oneParticipantStringConse(self):
    # Set up the codes so they are mapped later.
    SqlTestBase.setup_codes(["PIIState_VA", "male_sex", "male", "straight", "email_code", "en",
                             "highschool", "lotsofmoney"], code_type=CodeType.ANSWER)
    participant = self.send_post('Participant', {"providerLink": [self.provider_link]})
    participant_id = participant['participantId']
    with FakeClock(TIME_1):
      self.send_consent(participant_id)
    questionnaire_id = self.create_questionnaire('questionnaire3.json')

    # Populate some answers to the questionnaire
    answers = {
      'race': RACE_WHITE_CODE,
      'genderIdentity': 'male',
      'firstName': self.fake.first_name(),
      'middleName': self.fake.first_name(),
      'lastName': self.fake.last_name(),
      'zipCode': '78751',
      'state': 'PIIState_VA',
      'streetAddress': '1234 Main Street',
      'city': 'Austin',
      'sex': 'male_sex',
      'sexualOrientation': 'straight',
      'phoneNumber': '512-555-5555',
      'recontactMethod': 'email_code',
      'language': 'en',
      'education': 'highschool',
      'income': 'lotsofmoney',
      'dateOfBirth': datetime.date(1978, 10, 9),
      'CABoRSignature': 'signature.pdf',
    }

    self.post_demographics_questionnaire(participant_id, questionnaire_id, cabor_signature_string=True,
                                          **answers)

    with FakeClock(TIME_2):
      actual = self.send_get('Participant/%s/Summary' % participant_id)

    expected = self.create_expected_response(participant, answers)

    self.assertJsonResponseMatches(expected, actual)
    response = self.send_get('ParticipantSummary')
    self.assertBundle([_make_entry(actual)], response)


  def _send_next(self, next_link):
    prefix_index = next_link.index(main.PREFIX)
    return self.send_get(next_link[prefix_index + len(main.PREFIX):])

  def assertResponses(self, initial_query, summaries_list):
    response = self.send_get(initial_query)
    for i in range(0, len(summaries_list)):
      summaries = summaries_list[i]
      next_url = self.assertBundle([_make_entry(ps) for ps in summaries], response,
                                   has_next=i < len(summaries_list) - 1)
      if next_url:
        response = self._send_next(next_url)
      else:
        break

  def _submit_consent_questionnaire_response(self, participant_id, questionnaire_id,
                                             ehr_consent_answer, time=TIME_1):
    code_answers = []
    _add_code_answer(code_answers, "ehrConsent", ehr_consent_answer)
    qr = make_questionnaire_response_json(participant_id, questionnaire_id,
                                          code_answers=code_answers)
    with FakeClock(time):
      self.send_post('Participant/%s/QuestionnaireResponse' % participant_id, qr)

  def _submit_empty_questionnaire_response(self, participant_id, questionnaire_id):
    qr = make_questionnaire_response_json(participant_id, questionnaire_id)
    with FakeClock(TIME_1):
      self.send_post('Participant/%s/QuestionnaireResponse' % participant_id, qr)

  def _send_biobank_order(self, participant_id, order):
    with FakeClock(TIME_1):
      self.send_post('Participant/%s/BiobankOrder' % participant_id, order)

  def _store_biobank_sample(self, participant, test_code):
    BiobankStoredSampleDao().insert(BiobankStoredSample(
        biobankStoredSampleId='s' + participant['participantId'] + test_code,
        biobankId=participant['biobankId'][1:],
        test=test_code,
        biobankOrderIdentifier='KIT',
        confirmed=TIME_1))

  def testQuery_ehrConsent(self):
    questionnaire_id = self.create_questionnaire('all_consents_questionnaire.json')
    participant_1 = self.send_post('Participant', {})
    participant_id_1 = participant_1['participantId']
    self.send_consent(participant_id_1)
    ps_1 = self.send_get('Participant/%s/Summary' % participant_id_1)
    self.assertEquals('UNSET', ps_1['consentForElectronicHealthRecords'])

    self._submit_consent_questionnaire_response(participant_id_1, questionnaire_id, 'NOPE')
    ps_1 = self.send_get('Participant/%s/Summary' % participant_id_1)
    self.assertEquals('SUBMITTED_NO_CONSENT', ps_1['consentForElectronicHealthRecords'])

    self._submit_consent_questionnaire_response(participant_id_1, questionnaire_id,
                                                CONSENT_PERMISSION_YES_CODE)
    ps_1 = self.send_get('Participant/%s/Summary' % participant_id_1)
    self.assertEquals('SUBMITTED', ps_1['consentForElectronicHealthRecords'])

  def testQuery_manyParticipants(self):
    SqlTestBase.setup_codes(["PIIState_VA", "male_sex", "male", "straight", "email_code", "en",
                             "highschool", "lotsofmoney"], code_type=CodeType.ANSWER)

    questionnaire_id = self.create_questionnaire('questionnaire3.json')
    questionnaire_id_2 = self.create_questionnaire('questionnaire4.json')
    questionnaire_id_3 = self.create_questionnaire('all_consents_questionnaire.json')
    participant_1 = self.send_post('Participant', {"providerLink": [self.provider_link]})
    participant_id_1 = participant_1['participantId']
    participant_2 = self.send_post('Participant', {"providerLink": [self.provider_link]})
    participant_id_2 = participant_2['participantId']
    participant_3 = self.send_post('Participant', {})
    participant_id_3 = participant_3['participantId']
    with FakeClock(TIME_1):
      self.send_consent(participant_id_1)
      self.send_consent(participant_id_2)
      self.send_consent(participant_id_3)

    self.submit_questionnaire_response(participant_id_1, questionnaire_id, RACE_WHITE_CODE, "male",
                                       "Bob", "Q", "Jones", "78751", "PIIState_VA",
                                       "1234 Main Street", "Austin", "male_sex",
                                       "straight", "512-555-5555", "email_code",
                                       "en", "highschool", "lotsofmoney",
                                       datetime.date(1978, 10, 9), "signature.pdf")
    self.submit_questionnaire_response(participant_id_2, questionnaire_id, None, "female",
                                       "Mary", "Q", "Jones", "78751", None,
                                       None, None, None, None, None, None, None, None, None,
                                       datetime.date(1978, 10, 8), None)
    self.submit_questionnaire_response(participant_id_3, questionnaire_id, RACE_NONE_OF_THESE_CODE, "male",
                                       "Fred", "T", "Smith", "78752", None,
                                       None, None, None, None, None, None, None, None, None,
                                       datetime.date(1978, 10, 10), None)
    # Send a questionnaire response for the consent questionnaire for participants 2 and 3
    self._submit_consent_questionnaire_response(participant_id_2, questionnaire_id_3,
                                                CONSENT_PERMISSION_YES_CODE)
    self._submit_consent_questionnaire_response(participant_id_3, questionnaire_id_3,
                                                CONSENT_PERMISSION_YES_CODE)

    # Send an empty questionnaire response for another questionnaire for participant 3,
    # completing the baseline PPI modules.
    self._submit_empty_questionnaire_response(participant_id_3, questionnaire_id_2)

    # Send physical measurements for participants 2 and 3
    measurements_2 = load_measurement_json(participant_id_2, TIME_1.isoformat())
    measurements_3 = load_measurement_json(participant_id_3, TIME_1.isoformat())
    path_2 = 'Participant/%s/PhysicalMeasurements' % participant_id_2
    path_3 = 'Participant/%s/PhysicalMeasurements' % participant_id_3
    with FakeClock(TIME_2):
      self.send_post(path_2, measurements_2)
      # This pairs participant 3 with PITT and updates their version.
      self.send_post(path_3, measurements_3)


    # Send a biobank order for participant 1
    order_json = load_biobank_order_json(int(participant_id_1[1:]))
    self._send_biobank_order(participant_id_1, order_json)

    # Store samples for DNA for participants 1 and 3
    self._store_biobank_sample(participant_1, '1ED10')
    self._store_biobank_sample(participant_3, '1SAL')
    # Update participant summaries based on these changes.
    ParticipantSummaryDao().update_from_biobank_stored_samples()
    # Update version for participant 3, which has changed.
    participant_3 = self.send_get('Participant/%s' % participant_id_3)

    with FakeClock(TIME_3):
      participant_2['withdrawalStatus'] = 'NO_USE'
      participant_3['suspensionStatus'] = 'NO_CONTACT'
      participant_3['site'] = 'hpo-site-monroeville'
      self.send_put('Participant/%s' % participant_id_2, participant_2,
                    headers={ 'If-Match':'W/"2"'})
      self.send_put('Participant/%s' % participant_id_3, participant_3,
                     headers={ 'If-Match': participant_3['meta']['versionId'] })

    with FakeClock(TIME_4):
      ps_1 = self.send_get('Participant/%s/Summary' % participant_id_1)
      ps_2 = self.send_get('Participant/%s/Summary' % participant_id_2)
      ps_3 = self.send_get('Participant/%s/Summary' % participant_id_3)

    self.assertEquals(1, ps_1['numCompletedBaselinePPIModules'])
    self.assertEquals(1, ps_1['numBaselineSamplesArrived'])
    self.assertEquals('RECEIVED', ps_1['sampleStatus1ED10'])
    self.assertEquals(TIME_1.isoformat(), ps_1['sampleStatus1ED10Time'])
    self.assertEquals('UNSET', ps_1['sampleStatus1SAL'])
    self.assertEquals('UNSET', ps_1['samplesToIsolateDNA'])
    self.assertEquals('INTERESTED', ps_1['enrollmentStatus'])
    self.assertEquals('UNSET', ps_1['physicalMeasurementsStatus'])
    self.assertIsNone(ps_1.get('physicalMeasurementsTime'))
    self.assertEquals('male', ps_1['genderIdentity'])
    self.assertEquals('NOT_WITHDRAWN', ps_1['withdrawalStatus'])
    self.assertEquals('NOT_SUSPENDED', ps_1['suspensionStatus'])
    self.assertEquals('email_code', ps_1['recontactMethod'])
    self.assertIsNone(ps_1.get('withdrawalTime'))
    self.assertIsNone(ps_1.get('suspensionTime'))
    self.assertEquals('UNSET', ps_1['physicalMeasurementsCreatedSite'])
    self.assertEquals('UNSET', ps_1['physicalMeasurementsFinalizedSite'])
    self.assertIsNone(ps_1.get('physicalMeasurementsTime'))
    self.assertIsNone(ps_1.get('physicalMeasurementsFinalizedTime'))
    self.assertEquals('FINALIZED', ps_1['biospecimenStatus'])
    self.assertEquals('2016-01-04T09:40:21', ps_1['biospecimenOrderTime'])
    self.assertEquals('hpo-site-monroeville', ps_1['biospecimenSourceSite'])
    self.assertEquals('hpo-site-monroeville', ps_1['biospecimenCollectedSite'])
    self.assertEquals('hpo-site-monroeville', ps_1['biospecimenProcessedSite'])
    self.assertEquals('hpo-site-bannerphoenix', ps_1['biospecimenFinalizedSite'])
    self.assertEquals('UNSET', ps_1['sampleOrderStatus1ED04'])
    self.assertEquals('FINALIZED', ps_1['sampleOrderStatus1ED10'])
    self.assertEquals('2016-01-04T10:55:41', ps_1['sampleOrderStatus1ED10Time'])
    self.assertEquals('FINALIZED', ps_1['sampleOrderStatus1PST8'])
    self.assertEquals('FINALIZED', ps_1['sampleOrderStatus2ED10'])
    self.assertEquals('FINALIZED', ps_1['sampleOrderStatus1SST8'])
    self.assertEquals('FINALIZED', ps_1['sampleOrderStatus1HEP4'])
    self.assertEquals('FINALIZED', ps_1['sampleOrderStatus1UR10'])
    self.assertEquals('FINALIZED', ps_1['sampleOrderStatus1SAL'])

    # One day after participant 2 withdraws, their fields are still all populated.
    self.assertEquals(1, ps_2['numCompletedBaselinePPIModules'])
    self.assertEquals(0, ps_2['numBaselineSamplesArrived'])
    self.assertEquals('UNSET', ps_2['sampleStatus1ED10'])
    self.assertEquals('UNSET', ps_2['sampleStatus1SAL'])
    self.assertEquals('UNSET', ps_2['samplesToIsolateDNA'])
    self.assertEquals('MEMBER', ps_2['enrollmentStatus'])
    self.assertEquals('COMPLETED', ps_2['physicalMeasurementsStatus'])
    self.assertEquals(TIME_2.isoformat(), ps_2['physicalMeasurementsTime'])
    self.assertEquals('UNMAPPED', ps_2['genderIdentity'])
    self.assertEquals('NO_USE', ps_2['withdrawalStatus'])
    self.assertEquals('NOT_SUSPENDED', ps_2['suspensionStatus'])
    self.assertEquals('NO_CONTACT', ps_2['recontactMethod'])
    self.assertIsNotNone(ps_2['withdrawalTime'])
    self.assertEquals('hpo-site-monroeville', ps_2['physicalMeasurementsCreatedSite'])
    self.assertEquals('hpo-site-bannerphoenix', ps_2['physicalMeasurementsFinalizedSite'])
    self.assertEquals(TIME_2.isoformat(), ps_2['physicalMeasurementsTime'])
    self.assertEquals(TIME_1.isoformat(), ps_2['physicalMeasurementsFinalizedTime'])
    self.assertEquals('UNSET', ps_2['biospecimenStatus'])
    self.assertIsNone(ps_2.get('biospecimenOrderTime'))
    self.assertEquals('UNSET', ps_2['biospecimenSourceSite'])
    self.assertEquals('UNSET', ps_2['biospecimenCollectedSite'])
    self.assertEquals('UNSET', ps_2['biospecimenProcessedSite'])
    self.assertEquals('UNSET', ps_2['biospecimenFinalizedSite'])
    self.assertEquals('UNSET', ps_2['sampleOrderStatus1ED04'])
    self.assertIsNone(ps_2.get('sampleOrderStatus1ED10Time'))
    self.assertEquals('UNSET', ps_2['sampleOrderStatus1ED10'])
    self.assertEquals('UNSET', ps_2['sampleOrderStatus1PST8'])
    self.assertEquals('UNSET', ps_2['sampleOrderStatus2ED10'])
    self.assertEquals('UNSET', ps_2['sampleOrderStatus1SST8'])
    self.assertEquals('UNSET', ps_2['sampleOrderStatus1HEP4'])
    self.assertEquals('UNSET', ps_2['sampleOrderStatus1UR10'])
    self.assertEquals('UNSET', ps_2['sampleOrderStatus1SAL'])


    self.assertIsNone(ps_2.get('suspensionTime'))
    self.assertEquals(3, ps_3['numCompletedBaselinePPIModules'])
    self.assertEquals(0, ps_3['numBaselineSamplesArrived'])
    self.assertEquals('UNSET', ps_3['sampleStatus1ED10'])
    self.assertEquals('RECEIVED', ps_3['sampleStatus1SAL'])
    self.assertEquals(TIME_1.isoformat(), ps_3['sampleStatus1SALTime'])
    self.assertEquals('RECEIVED', ps_3['samplesToIsolateDNA'])
    self.assertEquals('FULL_PARTICIPANT', ps_3['enrollmentStatus'])
    self.assertEquals('COMPLETED', ps_3['physicalMeasurementsStatus'])
    self.assertEquals(TIME_2.isoformat(), ps_3['physicalMeasurementsTime'])
    self.assertEquals('male', ps_3['genderIdentity'])
    self.assertEquals('NOT_WITHDRAWN', ps_3['withdrawalStatus'])
    self.assertEquals('NO_CONTACT', ps_3['suspensionStatus'])
    self.assertEquals('NO_CONTACT', ps_3['recontactMethod'])
    self.assertEquals('hpo-site-monroeville', ps_3['site'])
    self.assertIsNone(ps_3.get('withdrawalTime'))
    self.assertIsNotNone(ps_3['suspensionTime'])

    # One day after participant 2 withdraws, the participant is still returned.
    with FakeClock(TIME_4):
      response = self.send_get('ParticipantSummary')
      self.assertBundle([_make_entry(ps_1), _make_entry(ps_2), _make_entry(ps_3)], response)

      self.assertResponses('ParticipantSummary?_count=2', [[ps_1, ps_2], [ps_3]])
      # Test sorting on fields of different types.
      self.assertResponses('ParticipantSummary?_count=2&_sort=firstName',
                           [[ps_1, ps_3], [ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&_sort:asc=firstName',
                           [[ps_1, ps_3], [ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&_sort:desc=firstName',
                           [[ps_2, ps_3], [ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&_sort=dateOfBirth',
                           [[ps_2, ps_1], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&_sort:desc=dateOfBirth',
                           [[ps_3, ps_1], [ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&_sort=genderIdentity',
                           [[ps_1, ps_3], [ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&_sort:desc=genderIdentity',
                           [[ps_2, ps_1], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&_sort=questionnaireOnTheBasics',
                           [[ps_1, ps_2], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&_sort=hpoId',
                           [[ps_1, ps_2], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&_sort:desc=hpoId',
                           [[ps_1, ps_2], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&_sort:desc=awardee',
                           [[ps_1, ps_2], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&_sort:desc=organization',
                           [[ps_1, ps_3], [ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&_sort:asc=site',
                           [[ps_2, ps_1], [ps_3]])
                           # Test filtering on fields.
      self.assertResponses('ParticipantSummary?_count=2&firstName=Mary',
                           [[ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&site=hpo-site-monroeville',
                           [[ps_1, ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&awardee=PITT',
                           [[ps_1, ps_2], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&organization=AZ_TUCSON_BANNER_HEALTH',
                           [])
      self.assertResponses('ParticipantSummary?_count=2&middleName=Q',
                           [[ps_1, ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&lastName=Smith',
                           [[ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&zipCode=78752',
                           [[ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&hpoId=PITT',
                           [[ps_1, ps_2], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&hpoId=UNSET',
                           [[]])
      self.assertResponses('ParticipantSummary?_count=2&genderIdentity=male',
                           [[ps_1, ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&race=WHITE',
                           [[ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&race=OTHER_RACE',
                           [[ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&middleName=Q&race=WHITE',
                           [[ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&middleName=Q&race=WHITE&zipCode=78752',
                           [[]])
      self.assertResponses('ParticipantSummary?_count=2&questionnaireOnTheBasics=SUBMITTED',
                           [[ps_1, ps_2], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&consentForStudyEnrollment=SUBMITTED',
                           [[ps_1, ps_2], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&consentForCABoR=SUBMITTED',
                           [[ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&physicalMeasurementsStatus=UNSET',
                           [[ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&physicalMeasurementsStatus=COMPLETED',
                           [[ps_2, ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&enrollmentStatus=INTERESTED',
                           [[ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&enrollmentStatus=MEMBER',
                           [[ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&enrollmentStatus=FULL_PARTICIPANT',
                           [[ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&dateOfBirth=1978-10-08',
                           [[ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&dateOfBirth=gt1978-10-08',
                           [[ps_1, ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&dateOfBirth=lt1978-10-08',
                           [[]])
      self.assertResponses('ParticipantSummary?_count=2&dateOfBirth=le1978-10-08',
                           [[ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&dateOfBirth=ge1978-10-08',
                           [[ps_1, ps_2], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&dateOfBirth=ge1978-10-08&'
                           'dateOfBirth=le1978-10-09', [[ps_1, ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&dateOfBirth=ne1978-10-09',
                           [[ps_2, ps_3]])

      self.assertResponses('ParticipantSummary?_count=2&withdrawalStatus=NOT_WITHDRAWN',
                           [[ps_1, ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&withdrawalStatus=NO_USE',
                           [[ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&withdrawalTime=lt2016-01-03',
                           [[]])
      self.assertResponses('ParticipantSummary?_count=2&withdrawalTime=ge2016-01-03',
                           [[ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&suspensionStatus=NOT_SUSPENDED',
                           [[ps_1, ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&suspensionStatus=NO_CONTACT',
                           [[ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&suspensionTime=lt2016-01-03',
                           [[]])
      self.assertResponses('ParticipantSummary?_count=2&suspensionTime=ge2016-01-03',
                           [[ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&physicalMeasurementsCreatedSite=UNSET',
                           [[ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&'
                           + 'physicalMeasurementsCreatedSite=hpo-site-monroeville',
                           [[ps_2, ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&physicalMeasurementsFinalizedSite=UNSET',
                           [[ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&'
                           + 'physicalMeasurementsFinalizedSite=hpo-site-bannerphoenix',
                           [[ps_2, ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&physicalMeasurementsStatus=UNSET',
                           [[ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&physicalMeasurementsStatus=COMPLETED',
                           [[ps_2, ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&biospecimenStatus=FINALIZED',
                           [[ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&biospecimenOrderTime=ge2016-01-04',
                           [[ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&biospecimenOrderTime=lt2016-01-04',
                           [[]])
      self.assertResponses('ParticipantSummary?_count=2&' +
                           'biospecimenSourceSite=hpo-site-monroeville',
                           [[ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&' +
                           'biospecimenCollectedSite=hpo-site-monroeville',
                           [[ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&' +
                           'biospecimenProcessedSite=hpo-site-monroeville',
                           [[ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&' +
                           'biospecimenFinalizedSite=hpo-site-bannerphoenix',
                           [[ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&sampleOrderStatus1ED04=UNSET',
                           [[ps_1, ps_2], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&sampleOrderStatus1ED10=FINALIZED',
                           [[ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&sampleOrderStatus1ED10Time=ge2016-01-04',
                           [[ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&sampleOrderStatus1ED10Time=lt2016-01-04',
                           [[]])

    # Two days after participant 2 withdraws, their fields are not set for anything but
    # participant ID, HPO ID, withdrawal status, and withdrawal time
    with FakeClock(TIME_5):
      new_ps_1 = self.send_get('Participant/%s/Summary' % participant_id_1)
      new_ps_2 = self.send_get('Participant/%s/Summary' % participant_id_2)
      new_ps_3 = self.send_get('Participant/%s/Summary' % participant_id_3)

    self.assertEquals(ps_1, new_ps_1)
    self.assertEquals(ps_3, new_ps_3)
    self.assertEquals('Mary', new_ps_2['firstName'])
    self.assertEquals('Q', new_ps_2['middleName'])
    self.assertEquals('Jones', new_ps_2['lastName'])
    self.assertIsNone(new_ps_2.get('numCompletedBaselinePPIModules'))
    self.assertIsNone(new_ps_2.get('numBaselineSamplesArrived'))
    self.assertEquals('UNSET', new_ps_2['sampleStatus1ED10'])
    self.assertEquals('UNSET', new_ps_2['sampleStatus1SAL'])
    self.assertEquals('UNSET', new_ps_2['samplesToIsolateDNA'])
    self.assertEquals('UNSET', new_ps_2['enrollmentStatus'])
    self.assertEquals('UNSET', new_ps_2['physicalMeasurementsStatus'])
    self.assertEquals('SUBMITTED', new_ps_2['consentForStudyEnrollment'])
    self.assertIsNotNone(new_ps_2['consentForStudyEnrollmentTime'])
    self.assertEquals('SUBMITTED', new_ps_2['consentForElectronicHealthRecords'])
    self.assertIsNotNone(new_ps_2['consentForElectronicHealthRecordsTime'])
    self.assertIsNone(new_ps_2.get('physicalMeasurementsTime'))
    self.assertEquals('UNSET', new_ps_2['genderIdentity'])
    self.assertEquals('NO_USE', new_ps_2['withdrawalStatus'])
    self.assertEquals(ps_2['biobankId'], new_ps_2['biobankId'])
    self.assertEquals('UNSET', new_ps_2['suspensionStatus'])
    self.assertEquals('NO_CONTACT', new_ps_2['recontactMethod'])
    self.assertEquals('PITT', new_ps_2['hpoId'])
    self.assertEquals(participant_id_2, new_ps_2['participantId'])
    self.assertIsNotNone(ps_2['withdrawalTime'])
    self.assertIsNone(new_ps_2.get('suspensionTime'))

    # Queries that filter on fields not returned for withdrawn participants no longer return
    # participant 2; queries that filter on fields that are returned for withdrawn participants
    # include it; queries that ask for withdrawn participants get back participant 2 only.
    # Sort order does not affect whether withdrawn participants are included.
    with FakeClock(TIME_5):
      self.assertResponses('ParticipantSummary?_count=2&_sort=firstName',
                           [[ps_1, ps_3], [new_ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&_sort:asc=firstName',
                           [[ps_1, ps_3], [new_ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&_sort:desc=firstName',
                           [[new_ps_2, ps_3], [ps_1]])
      self.assertResponses('ParticipantSummary?_count=2&_sort=dateOfBirth',
                           [[new_ps_2, ps_1], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&_sort:desc=dateOfBirth',
                           [[ps_3, ps_1], [new_ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&_sort=genderIdentity',
                           [[ps_1, ps_3], [new_ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&_sort:desc=genderIdentity',
                           [[new_ps_2, ps_1], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&_sort=questionnaireOnTheBasics',
                           [[ps_1, new_ps_2], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&_sort=hpoId',
                           [[ps_1, new_ps_2], [new_ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&_sort:desc=hpoId',
                           [[ps_1, new_ps_2], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&firstName=Mary',
                           [[new_ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&middleName=Q',
                           [[ps_1, new_ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&lastName=Smith',
                           [[ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&hpoId=PITT',
                           [[ps_1, new_ps_2], [ps_3]])
      self.assertResponses('ParticipantSummary?_count=2&withdrawalStatus=NO_USE',
                           [[new_ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&withdrawalTime=lt2016-01-03',
                           [[]])
      self.assertResponses('ParticipantSummary?_count=2&withdrawalTime=ge2016-01-03',
                           [[new_ps_2]])
      self.assertResponses('ParticipantSummary?_count=2&suspensionStatus=NOT_SUSPENDED',
                           [[ps_1]])

      self.assertResponses('ParticipantSummary?_count=2&lastModified=lt2016-01-04',
                           [[ps_3]])

def _add_code_answer(code_answers, link_id, code):
  if code:
    code_answers.append((link_id, Concept(PPI_SYSTEM, code)))

def _make_entry(ps):
  return { 'fullUrl': 'http://localhost/rdr/v1/Participant/%s/Summary' % ps['participantId'],
           'resource': ps }
